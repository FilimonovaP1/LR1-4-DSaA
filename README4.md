## Деревья
Дерево — это структура данных, в которой элементы организованы в виде иерархии. Каждый узел связан с одним родителем (за исключением корневого узла) и может иметь несколько дочерних элементов. Корень стоит на вершине структуры и не имеет родителя, а листья, наоборот, не содержат потомков. Подобная организация часто используется для представления каталогов на диске или построения схем подчинённости.

## Графы
Граф — более гибкая структура, состоящая из множества вершин и соединяющих их рёбер. Формально граф можно описать как G=(U,E), где U — набор вершин, а E — набор рёбер. Рёбра обычно представляют в виде пар [x, y]. Графы бывают направленными и ненаправленными, а также могут хранить веса рёбер или быть невзвешенными.

## Бинарные деревья в Python, Java и C++
Во всех трёх языках бинарное дерево строится на основе узлов, содержащих значение и ссылки на два поддерева — левое и правое. Операции добавления, поиска и удаления обычно реализуются в двух вариантах: на рекурсии и без неё.

## Python
Класс Node включает ключ и ссылки на левый и правый дочерние узлы, а отсутствующие ветви обозначаются None. Класс дерева содержит указатель на корень. Методы вставки, поиска и удаления могут быть реализованы рекурсивно. Для удаления часто используют функцию find_min, чтобы найти заменяющий элемент.

## Java
Узел обычно реализуют как вложенный статический класс с полями key/left/right. Вставка выполняется с помощью рекурсивного метода (например, doInsert), хотя возможен и итеративный обход. Предусмотрена обработка пустого дерева и повторяющихся значений.

## C++
Узлы задаются структурой TNode с указателями Left и Right. Рекомендуется использовать nullptr и инициализацию списка. В классе дерева реализуют деструктор, который рекурсивно высвобождает память. Итеративная вставка удобно реализуется через «указатель на указатель» (TNode**), что упрощает работу с пустыми ссылками.

## Графы и Дейкстра в Python, Java и C++
Алгоритм Дейкстры во всех трёх языках реализуется с использованием приоритетной очереди и различного представления графа.

## Python
Граф описывается словарём, где ключ — вершина, а значение — другой словарь со сценами и весами. Для приоритетной очереди применяется heapq. Начальные расстояния устанавливаются в бесконечность, затем постепенно улучшаются при обходе соседей.

## Java
Используются два подхода:
✓ матрица смежности с массивами расстояний и посещений;
✓ список смежности на основе ArrayList[] и PriorityQueue.
В PriorityQueue пары сравниваются по накопленному весу.

## C++
Граф хранится в виде vector<vector<Edge>>, где Edge содержит поле вершины-назначения и вес. Для выбора минимального расстояния применяется priority_queue с компаратором greater. Массивы расстояний и предков хранят текущие оценки и позволяют затем восстановить кратчайший путь.
