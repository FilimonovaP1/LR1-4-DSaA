# Понятие дерева и графа
## Что такое дерево
Дерево — это вид графа, который является связным и не содержит циклов. В нём имеется конечное число узлов и соединяющих их ребер, и между любыми двумя вершинами существует ровно один путь. Основные свойства дерева:
Выделяется особая вершина — корень.
Связи ориентированы от корневого узла к листьям, то есть вершинам, у которых нет потомков.
Каждая вершина (кроме корня) имеет одно входящее ребро.
Типичные примеры деревьев — иерархия папок на компьютере или родословная схема.

## Что такое граф
Граф — это структура, состоящая из набора вершин и ребер, которые определяют связи между ними. Графы бывают:
ориентированные (с направлением на ребрах) и неориентированные;
взвешенные (ребра имеют вес) и невзвешенные.
Классическими примерами графов являются дорожные карты, социальные сети и электрические схемы.
Создание деревьев и графов в Python, Java и C++

## Пример дерева на Python

```class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []
    def add_child(self, child):
        self.children.append(child)

#использование
root = TreeNode(1)
root.add_child(TreeNode(2))
root.add_child(TreeNode(3))
```

## Комментарий:
Объект TreeNode хранит значение и список всех потомков. Такая модель проста и может легко дополняться методами обхода и обработки узлов.

## Пример графа на Java

```import java.util.ArrayList;
import java.util.List;

class GraphVertex {
    int id;
    List<GraphVertex> neighbors;

    public GraphVertex(int id) {
        this.id = id;
        this.neighbors = new ArrayList<>();
    }

    public void addNeighbor(GraphVertex v) {
        neighbors.add(v);
    }
}

// Пример использования
GraphVertex A = new GraphVertex(1);
GraphVertex B = new GraphVertex(2);
A.addNeighbor(B);
B.addNeighbor(A);
```

## Комментарий:
Граф строится в виде списка смежности: у каждой вершины находится перечень соседних узлов. Такое представление удобно для редактирования структуры и эффективно по памяти.

## Пример графа на C++
```#include <iostream>
#include <vector>
using namespace std;

class Vertex {
public:
    int id;
    vector<Vertex*> neighbors;

    Vertex(int id) : id(id) {}

    void addNeighbor(Vertex* n) {
        neighbors.push_back(n);
    }
};

int main() {
    Vertex A(1), B(2);
    A.addNeighbor(&B);
    B.addNeighbor(&A);
    return 0;
}
```

## Комментарий:
Реализация аналогична версии на Java, но используется работа с указателями, что делает такую структуру быстрой и экономичной с точки зрения ресурсов.
Пошаговый разбор алгоритма DFS (глубинного поиска)

## Рассмотрим работу алгоритма обхода в глубину на дереве в Python:
```def dfs(node):
    visited = set()
    stack = [node]

    while stack:
        current = stack.pop()
        if current not in visited:
            visited.add(current)
            print(current.value)
            stack.extend(reversed(current.children))

#запуск
dfs(root)
```

## Шаги выполнения

Шаг 1. Старт алгоритма
Начальная вершина помещается в стек, а множество visited пока пустое.

Шаг 2. Итерации цикла
Пока стек содержит элементы:
Берем вершину сверху.
Проверяем, посещалась ли она ранее.
Если нет — добавляем в visited, выводим значение.
Помещаем её дочерние узлы в стек (в обратном порядке, чтобы обход выполнялся слева направо).

## Оценка сложности
Каждая вершина просматривается один раз, и каждое ребро — также один раз.
Если дерево содержит N узлов и E ребер, то сложность составляет:
O(N + E).
